//! [![Rust Windows](https://github.com/uglyoldbob/egui-multiwin/actions/workflows/windows_build.yml/badge.svg)](https://github.com/uglyoldbob/egui-multiwin/actions/workflows/windows_build.yml)
//! [![Rust MacOS](https://github.com/uglyoldbob/egui-multiwin/actions/workflows/macos_build.yml/badge.svg)](https://github.com/uglyoldbob/egui-multiwin/actions/workflows/macos_build.yml)
//! [![Rust Linux](https://github.com/uglyoldbob/egui-multiwin/actions/workflows/linux_build.yml/badge.svg)](https://github.com/uglyoldbob/egui-multiwin/actions/workflows/linux_build.yml)
//!
//! This crate is based on the work by vivlim (<https://github.com/vivlim>) and repository located (<https://github.com/vivlim/egui-glow-multiwin>).
//! Vivlim's example repository combines the work at <https://github.com/shivshank/mini_gl_fb/blob/master/examples/multi_window.rs> and egui to form a
//! nice package. This crate makes some modifications to make it useful as an external crate by defining a few traits for users to implement on their
//! custom structs.
//!
//! There are several examples (<https://github.com/uglyoldbob/egui-multiwin/tree/master/examples>) that show how to use this crate in your project.
//!
//! The majority of the code is created by the pair of macros named [`multi_window`](macro.multi_window.html) and [`tracked_window`](macro.tracked_window.html)
//!
//! The main struct for this crate is defined by the [`multi_window`](macro.multi_window.html) macro.
//!
//! Generally you will create a struct for data that is common to all windows, implement the `CommonEventHandler` trait on it.
//!
//! It will be useful to run `cargo doc --open` on your application to fully see the documentation for this module. This is because the majority of the code is generated by a pair of macros.
//!
//! See the examples in the repository for example applications that can be used to start your application.
//!
//! Check github issues to see if wayland (linux) still has a problem with the clipboard. That issue should give a temporary solution to a segfault that
//! occurs after closing a window in your program.
//!
//! In your main event, create an event loop, create an event loop proxy (if desired). The event loop proxy can be cloned and sent to other threads,
//! allowing custom logic to send events that can create windows and modify the common state of the application as required. Create a multiwindow instance,
//! then create window requests to make initial windows, and add them to the multiwindow with the add function. Create an instance of your common data
//! structure, and finally call run of your multiwindow instance.

#![deny(missing_docs)]
#![deny(clippy::missing_docs_in_private_items)]

use winit::window::WindowId;

pub use {
    arboard, egui, egui_glow, enum_dispatch, glutin, raw_window_handle, raw_window_handle_5,
    thiserror, winit,
};
pub mod multi_window;
pub mod tracked_window;

/// A generic non-event providing struct that users can use when they don't need custom events.
pub struct NoEvent {}

impl NoEvent {
    /// Returns a None for window_id
    pub fn window_id(&self) -> Option<WindowId> {
        None
    }
}
